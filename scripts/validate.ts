#!/usr/bin/env npx ts-node

/**
 * Pre-deployment validation script
 * Auto-generated by quality-setup
 */

import { execSync } from 'child_process'
import { readFileSync, readdirSync, statSync } from 'fs'
import { join } from 'path'

const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m'
}

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`)
}

function runCommand(command: string, description: string): boolean {
  log(`\nüîç ${description}...`, 'blue')
  try {
    execSync(command, { stdio: 'inherit', cwd: process.cwd() })
    log(`‚úÖ ${description} passed`, 'green')
    return true
  } catch {
    log(`‚ùå ${description} failed`, 'red')
    return false
  }
}

// Patterns that commonly cause hydration issues (React/Next.js)
const hydrationPatterns = [
  {
    pattern: /formatDistanceToNow\([^)]+\)/,
    message: 'formatDistanceToNow - wrap in useEffect to avoid hydration mismatch'
  },
  {
    pattern: /new Date\(\)\.toLocaleString/,
    message: 'toLocaleString with new Date() - may cause hydration mismatch'
  },
  {
    pattern: /Math\.random\(\)/,
    message: 'Math.random() - use in event handlers or useEffect only'
  }
]

function getAllSourceFiles(dir: string, files: string[] = []): string[] {
  if (!statSync(dir).isDirectory()) return files

  const items = readdirSync(dir)
  for (const item of items) {
    const fullPath = join(dir, item)
    try {
      const stat = statSync(fullPath)
      if (stat.isDirectory() && !item.includes('node_modules') && !item.startsWith('.')) {
        getAllSourceFiles(fullPath, files)
      } else if (item.match(/\.(tsx|jsx)$/)) {
        files.push(fullPath)
      }
    } catch {
      // Skip inaccessible files
    }
  }
  return files
}

function checkHydrationPatterns(): number {
  log('\nüîç Checking for potential hydration issues...', 'blue')

  const srcDirs = ['src', 'app', 'pages', 'components'].filter(d => {
    try { return statSync(join(process.cwd(), d)).isDirectory() } catch { return false }
  })

  let warnings = 0

  for (const srcDir of srcDirs) {
    const files = getAllSourceFiles(join(process.cwd(), srcDir))

    for (const file of files) {
      if (file.includes('/api/')) continue

      const content = readFileSync(file, 'utf-8')
      const relativePath = file.replace(process.cwd(), '.')

      for (const { pattern, message } of hydrationPatterns) {
        if (pattern.test(content)) {
          log(`  ‚ö†Ô∏è  ${relativePath}: ${message}`, 'yellow')
          warnings++
        }
      }
    }
  }

  if (warnings === 0) {
    log('‚úÖ No obvious hydration issues found', 'green')
  } else {
    log(`\n  Found ${warnings} potential issues (review manually)`, 'yellow')
  }

  return warnings
}

async function main() {
  log('üöÄ Starting validation...', 'blue')
  log('='.repeat(50))

  let allPassed = true

  // TypeScript check
  if (!runCommand('npx tsc --noEmit', 'TypeScript compilation')) {
    allPassed = false
  }

  // ESLint check
  if (!runCommand('npx next lint', 'ESLint')) {
    allPassed = false
  }

  // Hydration patterns (React/Next.js projects)
  checkHydrationPatterns()

  // Build check (optional)
  if (process.argv.includes('--build')) {
    if (!runCommand('npm run build', 'Production build')) {
      allPassed = false
    }
  } else {
    log('\nüí° Tip: Run with --build flag to include production build check', 'yellow')
  }

  log('\n' + '='.repeat(50))
  if (allPassed) {
    log('‚úÖ All validations passed!', 'green')
    process.exit(0)
  } else {
    log('‚ùå Some validations failed. Please fix the issues above.', 'red')
    process.exit(1)
  }
}

main().catch(console.error)
